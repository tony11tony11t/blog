<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[Master the Coding Interview] 取得面試機會</title>
    <url>/blog/2021/11/30/Master_The_Coding-interview/</url>
    <content><![CDATA[<p><strong><font color=#FF6600>本篇為Master the Coding Interview教學影片筆記文</font></strong></p>
<h3 id="1-Resume"><a href="#1-Resume" class="headerlink" title="1. Resume"></a>1. Resume</h3><p>履歷是公司看你的第一印象，他們通常不會很仔細的去看，畢竟有太多太多的應徵者，所以我們不應該花太多時間在著磨履歷上的小地方、字型、顏色等。履歷最好花一天就要搞定，避免浪費時間。</p>
<p>不過以上是專屬於工程師，如果你是一個設計師或其他職業就要依照職業的特性來製作出符合的履歷，以下是履歷需要著重的四個部分：</p>
<ol>
<li>One page<br>一頁就好，公司不會一次想要看那麼多</li>
<li>Relavant Skills<br>相關的技能一定要寫上去，讓公司一目就可以了然你會什麼</li>
<li>Personalized<br>要依照每個公司稍微對履歷做一些變動，可能改改簡介內容或大標題等</li>
<li>Online Link<br>要讓履歷可以連上你的github</li>
</ol>
<p>可以透過以下的條件檢視一下自己的履歷：</p>
<ul>
<li>使用一個已經設計好的模板</li>
<li>控制履歷的內容在一頁之內</li>
<li>要包含你對工作的描述</li>
<li>要加入你要應徵的公司名稱</li>
<li>要讓履歷中每個大項目中的第一個小項目是最吸引人的部分  <blockquote>
<p>例如我們寫到專業技能，如果你是要應徵工程師，第一項專業技能一定要是那方面的東西，並且依照應徵工作的性質來排序</p>
</blockquote>
</li>
<li>在該強調的地方做強調<blockquote>
<p>例如我們寫到工作經驗，要強調的是工作的職位和工作的內容，而不是公司的名稱</p>
</blockquote>
</li>
<li>記得附上連結，不管是Github或是blog的都可以</li>
<li>不要用「我」<blockquote>
<p>用第一人稱寫履歷會有很多冗詞贅字，應該改為用第三人稱</p>
</blockquote>
</li>
<li>不要加入一些流行用詞</li>
<li>利用動詞來描述事情會更讓人加深印象</li>
<li>確定每件事都講得很具體，不要有很模糊的描述</li>
<li>在描述你的技能程度時，可以用具體的事跡說明</li>
<li>每個項目中的內容都只要放符合應徵職位的就好</li>
<li>沒有任何的錯字和吻法錯誤</li>
</ul>
<p>檢視完自己的履歷後，還是要再次強調履歷只能讓你有機會面試，不能讓你得到工作，更重要的還是面試的技巧跟作品集，所以不要花太多時間在設計履歷，更重要的是，要對自己的履歷百分之百的誠實，避免面試的時候對於自己的問題答不出來。</p>
<p>接下來要講講如果是新鮮人，沒辦法有過多的工作經驗、作品等東西做出好看的履歷的話，可以利用以下四種方式來增加自己的履歷深度：</p>
<ol>
<li>GitHub<br> 如果這個帳號很活躍，代表說他可以和其他人一同工作也會做版本控制，自己沒有專案沒關係，可以拿別人的過來建置，都是公司很樂見的部分。</li>
<li>Website<br> 做一個自己的個人網頁，不一定要自己寫一個，可以套用網路上的模板來展示自己，這邊跟履歷一樣，不用過多華麗的特效，簡單能夠展示自己的作品即可。</li>
<li>1~2個大型專案<br> 少數的大型專案比起多個小專案來的更有價值，面試的時候你不能展示所有的小專案，只花1~2天做完的東西基本上都太簡單了，不會讓人印象深刻，與其花時間在小專案，不如做出一個需要一段時程才能完成的大型專案。而且通常面試官都會問你做過最難的專案為何，做過大型專案才能讓自己講出的東西較為深刻。<br/>如果沒有相關的工作經驗，在履歷上放入作品也是另外一種選擇，但要注意的是必須強調出作品的相關技能讓面試官能夠一目了然在此作品中你所學習到的東西。</li>
<li>部落格<br> 經營部落格，把自己學到的技術寫成文章也是加強自身價值的方法，在面試的時候展現能夠讓面試官印象深刻。</li>
</ol>
<p>透過以上四種加強履歷的方法，儘管沒有工作經驗也可以讓履歷不會空空如也，但要注意的是，如果你只有學程式可能半年，千萬不要寫上去，面試官在篩選人的時候如果看到絕對先丟掉，畢竟這種人的風險很高，展現好的一面，這是面試的不二法則。</p>
<h3 id="2-Linkedln"><a href="#2-Linkedln" class="headerlink" title="2. Linkedln"></a>2. Linkedln</h3><p>這是一個全世界的求職平台，此平台也是許多公司找人才的地方，很多人會覺得Linkedln上面的資料比履歷更重要，只要profile有內容就容易有公司找你，下面有幾個小心機重點可以讓公司找人才的時候更容易找到你。</p>
<ol>
<li>update your profile<br>不一定要真的更新，只要時常的去編輯再更新，就會讓自己的履歷一直處在新的狀態，也會讓公司知道自己最近在找工作。</li>
<li>keywords<br>在履歷上多寫一些關鍵字，例如你曾經用過Firebase，就把他寫上去，如果有公司是想找會用Firebase的人的話你就會出現在他的搜尋結果裡。</li>
<li>Recommendations<br>雖然這個在面試時沒有人會看，但多一點的評論也會讓自己的rank提高，容易出現在搜尋結果的上面。</li>
<li>create connect<br>利用公司來找到linkedln上面正在你想要的公司上班的人，並與他們製造關係或私訊他們。</li>
</ol>
<h3 id="3-Portfolio"><a href="#3-Portfolio" class="headerlink" title="3. Portfolio"></a>3. Portfolio</h3><p>和履歷一樣，只要有一個地方可以放上作品以便面試的時候可以展示就好，不需要利用太多時間來設計版面和網頁，但就是一定要有這項東西可以展示。</p>
<h3 id="4-Email"><a href="#4-Email" class="headerlink" title="4. Email"></a>4. Email</h3><p>公司其實最常會應徵透過朋友介紹的人，如果我們沒有親朋好友在你要面試的公司裡，那Email相對就很重要了，求職雖然可以透過求職網，但如果透過寄信的方式，也可以提高人資看到應徵者訊息的機會，也能增加獲得面試的機會。除了直接寄信詢問職缺外，更好的是與他人建立連結，利用linkedln或是其他東西來取得CEO或HR的Eemail，可以嘗試跟他們約出來聊天，約成功的同時你也算成功拿到面試了。</p>
<p>總結一下，以上四點是找工作必須要有的四樣東西，那甚麼時候該找工作呢，now，開始找工作你才能知道自己哪裡不足，哪裡需要加強，但這個答案只適用於已經有基本知識的人，如果是個新手工程師，那還是快點準備履歷，快點開始動手寫程式，做大型的project，讓自己更熟練這項技能。</p>
<p>在找工作的時候當然上面會寫很多必要條件、工作資歷等，千萬不要因此打退堂鼓，上面寫的只是他們公司會用到的技能，也可能是未來你需要學的技能，絕對不是「現在」你就已經要會的技能，唯有拿到面試機會面對面開始才是真的。雖然找工作是一個數量遊戲，投越多家越有取得面試的機會，但與其把履歷灑到求職網上，不如找出大約10家自己喜歡的公司，針對他們個別去做準備，只要做好準備，機會也不一定會比海投來得更小。</p>
]]></content>
      <categories>
        <category>Master the Coding Interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>resume</tag>
      </tags>
  </entry>
  <entry>
    <title>[Complete React Developer in 2022]React介紹</title>
    <url>/blog/2021/11/30/React-Tutorial-01/</url>
    <content><![CDATA[<p><strong><font color=#FF6600>本篇為Complete React Developer in 2022教學影片筆記文</font></strong></p>
<p>傳統的網頁呈現方式，是將所有的HTML、CSS、JS的檔案上傳到server，等到使用者要讀取網頁的時候再從server呼叫出來顯示在瀏覽器上，每一次有一個新的頁面時就會再重複一次從server讀取檔案的這個步驟，這是一套行之有年的網頁模式。但漸漸的問題來了，越來越多種瀏覽器問世，每種瀏覽器又有不同的編譯方式，導致開發者需要開發許多種網頁來因應每種瀏覽器，讓網頁開發增加了許多難度。</p>
<p>接著，jQuery問世了，他整合了所有瀏覽器的問題，做出了非常簡單的API工具，透過jQuery可以快速的讓使用者與網頁互動，並且大大縮短開發速度。但人的慾望沒有極限，工程師開始會想要開發更大的專案，功能開始變的複雜，像是Facebook，有帳戶、可以線上即時聊天、寄信等，不再只是像blog一樣發發文章做做新的頁面了。</p>
<p>當jQuery沒辦法再應付大型專案的時候，backbone.js出來了，SPA(single page application)的概念也跟著出來，網頁不再只是每次要新的就去server load，而是變成放大js的功能，縮小html的地位，利用js來改變當前html的內容，達到SPA的一個概念，這也是為什麼網頁不再只是一個頁面而是稱為應用程式了。</p>
<p>2010年，由Google創造的Angular.js出現，不同於jQuery，有了MVC的概念，把每一塊程式碼都變成一個包裹的概念，讓其不會互相干擾，讓工程師之間更容易合作。但很快就有一個問題出現了，網頁上的每個部份都會互相影響，迎來的是資料越來越散落在各個包裹裡，讓Debug越來越難。</p>
<p>2013年，Facebook是出了第一版的React，解決了資料流的問題，讓資料不會散落在各地，也是因為如此，2014年的時候Angular.js意識到自己沒辦法再創造出好的SPA後，他們直接重寫了library，並改名為Angular，的確就是把js拿掉，但也因為這個重寫，很多開發者直接轉向投入React，也讓現今一堆大公司都使用了React來作為主要框架。</p>
<p>以下是react的幾個原則：</p>
<ol>
<li>Don’t touch the DOM. I’ll do it.<br>只要給React資料，就可以利用他幫忙套入資料，不需要更改DOM來達到更換頁面呈現的資料。</li>
<li>Build websites like lego blocks<br>React的一大特性就是components，模組化跟樂高一樣，一個網頁就像是很多樂高很多組件拼湊而成的，開發的components還可以到處重複利用，十分彈性。</li>
<li>Unidirectional data flow<br>react的資料流向，有一個限制就是只能往下不能往上，資料只能單向溝通，這讓開發者可以更清楚知道資料在app裡面的流向，更容易去處理bug。</li>
<li>UI, The rest is up to you<br>React專注於ocmponenet的產生，只要有這個React的藍圖，我們就可以在任何地方建置他，手機、電腦、terminal等等都可以，這就是React跨平台的應用，當然，如果是一般的網頁，我們就要用到React何React-DOM</li>
</ol>
<p>如果要成為一個成熟的React工程師，要記得以下三點開發的原則</p>
<ol>
<li>Decide on Components</li>
<li>Decide the State and where it lives</li>
<li>What changes when state changes</li>
</ol>
]]></content>
      <categories>
        <category>Complete React Developer in 2022</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>[Master the Coding Interview] BigO介紹</title>
    <url>/blog/2021/12/02/Master-The-Coding-BigO/</url>
    <content><![CDATA[<p><strong><font color=#FF6600>本篇為Master the Coding Interview教學影片筆記文</font></strong></p>
<h3 id="What-is-good-code"><a href="#What-is-good-code" class="headerlink" title="What is good code?"></a>What is good code?</h3><p>什麼是好的程式碼，好的程式碼是Readable和Scalable的，BigO可以拿來測量程式的執行速度，所以這章會著重在Scalable的部分。</p>
<h3 id="BigO"><a href="#BigO" class="headerlink" title="BigO"></a>BigO</h3><p>BigO為什麼會存在，因為當我們要判斷一個code好或不好的時候，如果用執行的時間來看的話，因為每個電腦CPU的不同，會有執行速度上的差異，同樣的code不同的設備會有不同的速度，所以不能以時間來做為依據，這時候我們就會用BigO來判斷code執行速度。</p>
<p>BigO主要是利用程式執行多少步驟來做計算，拿以下的程式碼來說：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHappy</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">&quot;Happy&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printHappy(n);  <span class="comment">//O(n) --&gt;linear time</span></span><br></pre></td></tr></table></figure>

<p>假設今天n是1，那這個for迴圈就會執行1次，n=2就會執行兩次，n=100就會執行100次，以此類推，我們可以發現n跟執行的次數呈現一個正比，並且是線性的增加，透過這個方式我們可以說這個printHappy的函式時間複雜度是O(n)。</p>
<p>O(1)表示constant time，表示不管甚麼input進去，這個function都會執行一樣數量的步驟，是時間複雜部裡面最好的一種。</p>
<p><strong>BigO Challenge</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funChallenge</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;  <span class="comment">//O(1)</span></span><br><span class="line">  a = <span class="number">50</span> + <span class="number">3</span>;  <span class="comment">//O(1)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123; <span class="comment">//O(n)</span></span><br><span class="line">    anotherFunction(); <span class="comment">//O(n)</span></span><br><span class="line">    <span class="keyword">let</span> stranger = <span class="literal">true</span>; <span class="comment">//O(n)</span></span><br><span class="line">    a++; <span class="comment">//O(n)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a; <span class="comment">//O(1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，有些人說賦值不能算是一個步驟，但這邊先不討論這部分，所以賦值就給他O(1)，for迴圈的東西就是執行n次，接著將所有的BigO加起來，我們會得到O(3 + 4n)的時間複雜度的，接著我們就會簡化她，把常數消掉後，取最複雜的那個就好，所以這題的答案是O(n)。</p>
<p>當然我們在面試的時候，不會一行一行的算出來，我們必須一眼就看出時間複雜度為何，以下有四個遵循的規則：</p>
<ol>
<li>Worst Case<br>永遠要設定成最糟的情況，因為BigO只會看最壞情況。</li>
<li>Remove Constants<br>因為input要假設成一個很大很大的數字，所以常數對他們來說不重要。</li>
<li>Different terms for inputs<br>不同的input要用不同的代數去寫，假設function裡面有兩個迴圈一個有m個element一個n個element的話，會把結果寫成O(m + n)，因為不會知道到你m多還是n多，所以都要寫上去。</li>
</ol>
<blockquote>
<p>如果兩個迴圈都同樣有n個element，並且又是一個巢狀的話，我們就可以把結果寫成O(n^2)，這是一個不好的時間複雜度，很多面試就是要請你把O(^2)變成較好的時間複雜度。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//O(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">//O(n)</span></span><br><span class="line">    <span class="built_in">console</span>.log(i,j)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>Drop Non Dominants<br>丟掉不重要的部分，假設function裡面有一個時間複雜度是O(n)，一個是O(n^2)，我們會取最複雜的，也就是O(n^2)。</li>
</ol>
<p>O(n!)這是最糟糕的時間複雜度，等於說每次執行loop都要加一個element，絕對要避免。</p>
<p>到這邊已經介紹了3種時間複雜度，接著要回到Scalable這個點上，時間複雜度表示的是他的run time，但除了時間，memory也是注重的一個環節，要符合Scalable，必須考慮時間跟空間，雖然現在的memory越來越大，但她不是無限的，我們仍然要注意使用的大小。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boo</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//O(n)</span></span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">boo(<span class="number">5</span>) <span class="comment">//O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayOfHiNTimes</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> hiArray = [];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//O(n)</span></span><br><span class="line">    hiArray[i] = <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arrayOfHiNTimes(<span class="number">6</span>)  <span class="comment">//O(n)</span></span><br></pre></td></tr></table></figure>

<p>第一個function裡面，雖然是一個迴圈，但我們只有在for迴圈裡面宣告一個i，整個函式也只有宣告這個東西，可以說boo function的空間複雜度為O(1)。第二個就不一樣了，因為我們宣告了一個陣列，並且在陣列加入了n個elements，所以arrayOfHiNTimes function的空間複雜度為O(n)。</p>
<p>通常我們會用空間換取時間或時間換取空間，這沒有甚麼對或錯，看當下的project要怎麼做就好。</p>
]]></content>
      <categories>
        <category>Master the Coding Interview</category>
      </categories>
      <tags>
        <tag>BigO</tag>
      </tags>
  </entry>
</search>
